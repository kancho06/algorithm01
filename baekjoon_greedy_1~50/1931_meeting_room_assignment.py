# 문제
# 한 개의 회의실이 있는데 이를 사용하고자 하는 N개의 회의에 대하여 회의실 사용표를 만들려고 한다.
# 각 회의 I에 대해 시작시간과 끝나는 시간이 주어져 있고,
# 각 회의가 겹치지 않게 하면서 회의실을 사용할 수 있는 회의의 최대 개수를 찾아보자.
# 단, 회의는 한번 시작하면 중간에 중단될 수 없으며 한 회의가 끝나는 것과 동시에 다음 회의가 시작될 수 있다.
# 회의의 시작시간과 끝나는 시간이 같을 수도 있다. 이 경우에는 시작하자마자 끝나는 것으로 생각하면 된다.
#
# 입력(input)
# 첫째 줄에 회의의 수 N(1 ≤ N ≤ 100,000)이 주어진다.
# 둘째 줄부터 N+1 줄까지 각 회의의 정보가 주어지는데 이것은 공백을 사이에 두고 회의의 시작시간과 끝나는 시간이 주어진다.
# 시작 시간과 끝나는 시간은 231-1보다 작거나 같은 자연수 또는 0이다.
#
# 출력(output)
# 첫째 줄에 최대 사용할 수 있는 회의의 최대 개수를 출력한다.
#
# 풀이 방법
# 4
# 0 10
# 3 4
# 2 3
# 1 2
# 가 있을 때 시작 순서대로하면 (0 10)으로 1번의 회의가 가능하지만,
# 끝나는 시간으로 정렬을 한다면 (1 2) (2 3) (3 4) 총 3번의 회의가 가능해진다.
#
# 그리고 한가지 더 고려해야 하는 점이 있는데, 끝나는 시간이 같을 경우이다.
# 끝나는 시간이 같다면 빨리 시작하는 순서대로 정렬이 되어야 한다.
# 예를 들자면
# 2
# 2 2
# 1 2
# 의 경우 이 상태로 한다면 (2 2)가 되고
# (1 2)는 (2 2)의 끝나는 시간보다 시작시간이 일찍이기 때문에 무시되어 1번의 회의가 진행된다고 나온다.
# 하지만 정렬을 통해 (1 2)가 먼저 선택되면 (2 2)도 선택이 가능해지기 때문에 가능한 회의는 2번으로 결정된다.
#
# 그렇기 때문에 정렬을
# 1. 끝나는 시간의 오름차순
# 2. 시작하는 시간의 오름차순
# 두번 해주어야한다.


n = int(input())
info = [[0] * 2 for _ in range(n)]  # 시작과 끝시간을 받기 위해서 [0]이 두번들어가 있는 리스트를 n 개 만든다
for i in range(n):
    s, e = map(int, input().split())
    info[i][0] = s
    info[i][1] = e

info.sort(key=lambda x: (x[1], x[0]))  # 끝시간 오름차순 , 시작시간 오름차순 (sort 람다는 기본 오름차순 정렬)

cnt = end = 0

for s, e in info:       # 시작시간이 끝나는시간보다 같거나 크다면 카운트하고 끝나는 시간을 갱신한다.
    if s >= end:
        cnt += 1
        end = e
print(cnt)
