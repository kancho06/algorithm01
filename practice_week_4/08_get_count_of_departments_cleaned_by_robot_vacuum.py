# 문제
# 로봇 청소기가 주어졌을 때, 청소하는 영역의 개수를 구하는 프로그램을 작성하시오.
# 로봇 청소기가 있는 장소는 NM 크기의 직사각형으로 나타낼 수 있으며, 1×1크기의 정사각형 칸으로 나
# 누어져 있다. 각각의 칸은 벽 또는 빈 칸이다. 청소기는 바라보는 방향이 있으며, 이 방향은 동, 서, 남, 북중
# 하나이다. 지도의 각 칸은 (r, c)로 나타낼 수 있고, r은 북쪽으로부터 떨어진 칸의 개수, c는 서쪽으로 부터
# 떨어진 칸의 개수이다.
# 로봇 청소기는 다음과 같이 작동한다.
# 1. 현재 위치를 청소한다.
# 2. 현재 위치에서 현재 방향을 기준으로 왼쪽방향부터 차례대로 탐색을 진행한다.
# a. 왼쪽 방향에 아직 청소하지 않은 공간이 존재한다면, 그 방향으로 회전한 다음 한 칸을 전진하고 1번
# 부터 진행한다.
# b. 왼쪽 방향에 청소할 공간이 없다면, 그 방향으로 회전하고 2번으로 돌아간다.
# c. 네 방향 모두 청소가 이미 되어있거나 벽인 경우에는, 바라보는 방향을 유지한 채로 한 칸 후진을 하
# 고 2번으로 돌아간다.
# d. 네 방향 모두 청소가 이미 되어있거나 벽이면서, 뒤쪽 방향이 벽이라 후진도 할 수 없는 경우에는 작
# 동을 멈춘다.
# 로봇 청소기는 이미 청소되어있는 칸을 또 청소하지 않으며, 벽을 통과할 수 없다.
#
# 입력 조건
# 로봇 청소기가 있는 칸의 좌표 (r, c)와 바라보는 방향 d가 주어진다. 이 때 d가 0인 경우에는 북쪽을, 1인
# 경우에는 동쪽을, 2인 경우에는 남쪽을, 3인 경우에는 서쪽을 바라보고 있는 것이다.
# 또한 청소하고자 하는 방의 지도를 2차원 배열로 주어진다.
# 빈 칸은 0, 벽은 1로 주어진다. 지도의 첫 행, 마지막 행, 첫 열, 마지막 열에 있는 모든 칸은 벽이다.
# 로봇 청소기가 있는 칸의 상태는 항상 빈 칸이라고 했을 때,
# 로봇 청소기가 청소하는 칸의 개수를 반환하시오.


current_r, current_c, current_d = 7, 4, 0
current_room_map = [
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
    [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
    [1, 0, 0, 0, 1, 1, 1, 1, 0, 1],
    [1, 0, 0, 1, 1, 0, 0, 0, 0, 1],
    [1, 0, 1, 1, 0, 0, 0, 0, 0, 1],
    [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
    [1, 0, 0, 0, 0, 0, 0, 1, 0, 1],
    [1, 0, 0, 0, 0, 0, 1, 1, 0, 1],
    [1, 0, 0, 0, 0, 0, 1, 1, 0, 1],
    [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
]
# 전부 탐색, 모든 곳 탐색 BFS
# 1. 현재 위치를 청소한다. (기억해야함)
#      0은 청소하지 않은 장소 , 1은 청소하지 못하는 장소 , 2 는 청소한 장소
# 2. 현재 위치에서 현재 방향을 기준으로 왼쪽 방향부터 차례대로 탐색을 진행한다.
#    a. 왼쪽 방향에 아직 청소하지 않은 공간이 존재한다면,
#       그 방향으로 회전한 다음 한 칸을 전진하고 1번부터 진행한다.
#    b. 왼쪽 방향이 청소할 공간이 없다면, 그 방향으로 회전하고(다시 왼쪽으로 회전하고) 2번으로 돌아간다.
#    c. 네 방향 모두 청소가 되어있거나 벽인 경우에는 바라보는 방향을 유지한 채로 한 칸 후진을 하고 2번으로 돌아간다.
#    d. 네 방향 모두 청소가 이미 되어있거나 벽이면서, 뒤쪽 방향이 벽이라 후진도 할 수 없는 경우에는 작동을 멈춘다.
#
# 방향(으로 갈때)
#        row(r)  calum(c)
# 북쪽    -1       0
# 동쪽     0       1
# 남쪽     1       0
# 서쪽     0      -1
#    북  동  남  서
dr = [-1, 0, 1, 0]
dc = [0, 1, 0, -1]


#
# 회전
# 북쪽에서 왼쪽으로 회전 = 서  0번째 인덱스 -> 3번째 인덱스
# 동쪽에서 왼쪽으로 회전 = 북  1 -> 0
# 남쪽에서 왼쪽으로 회전 = 동  2 -> 1
# 서쪽에서 왼쪽으로 회전 = 남  3 -> 2
#
# 후진
# 북쪽에서 뒤로 돌기 = 남 0 -> 2
# 동쪽에서 뒤로 돌기 = 서 1 -> 3
# 남쪽에서 뒤로 돌기 = 북 2 -> 0
# 서쪽에서 뒤로 돌기 = 동 3 -> 1


# 왼쪽으로 회전할 시 방향 계산 함수    d는 인덱스 번호(방향 인덱스번호)
def get_d_index_when_rotate_to_left(d):
    return (d + 3) % 4


# 뒤로 돌시 방향 계산 함수    d는 인덱스 번호(방향 인덱스번호)
def get_d_index_when_goback(d):
    return (d + 2) % 4


def get_count_of_departments_cleaned_by_robot_vacuum(r, c, d, room_map):
    n = len(room_map)  # 방의 세로 크기
    m = len(room_map[0])  # 방의 가로 크기
    count_of_departments_cleaned = 1  # 잇는방은 청소가 된 것으로 카운트
    room_map[r][c] = 2  # 지금 있는 방을 청소를 한 방으로 쳐서 2 로 만든다.
    queue = list([[r, c, d]])

    while queue:  # queue 가 끝날때 까지
        r, c, d = queue.pop(0)
        temp_d = d

        for i in range(4):  # 4방향 탐색
            temp_d = get_d_index_when_rotate_to_left(temp_d)  # 왼쪽으로 회전
            new_r, new_c = r + dr[temp_d], c + dc[temp_d]  # 한칸 앞으로

            if 0 <= new_r < n and 0 <= new_c < m and room_map[new_r][new_c] == 0:  # 가로 세로 범위에 들어가고, 청소가 안된 방일때
                count_of_departments_cleaned += 1  # 청소 카운트 +1
                room_map[new_r][new_c] = 2  # 방을 청소한 방으로 바꿈
                queue.append([new_r, new_c, temp_d])  # 현재 지점 저장
                break
            # c. 네 방향 모두 청소가 되어있거나 벽인 경우에는 한칸 후진하고 2번으로
            elif i == 3:
                new_r, new_c = r + dr[get_d_index_when_goback(temp_d)], c + dc[get_d_index_when_goback(temp_d)]
                queue.append([new_r, new_c, temp_d])

                # d. 네 방향 모두 청소가 이미 되어있거나 벽이면서, 뒤쪽 방향이 벽이라 후진도 할 수 없는 경우에 작동을 멈춘다.
                if current_room_map[new_r][new_c] == 1:
                    return count_of_departments_cleaned

    return


# 57 이 출력되어야 합니다!
print(get_count_of_departments_cleaned_by_robot_vacuum(current_r, current_c, current_d, current_room_map))
